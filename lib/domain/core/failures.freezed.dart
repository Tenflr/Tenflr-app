// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

// ignore: unused_element
  ShortAccountName<T> shortAccountName<T>({@required T failedValue}) {
    return ShortAccountName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidEmail<T> invalidEmail<T>({@required T failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidTransactionType<T> invalidTransactionType<T>(
      {@required T failedValue}) {
    return InvalidTransactionType<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidUserName<T> invalidUserName<T>({@required T failedValue}) {
    return InvalidUserName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidStatus<T> invalidStatus<T>({@required T failedValue}) {
    return InvalidStatus<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidName<T> invalidNames<T>({@required T failureValue}) {
    return InvalidName<T>(
      failureValue: failureValue,
    );
  }

// ignore: unused_element
  _PhoneNumberNotSupported<T> phoneNumberNotSupported<T>(
      {@required T failedValue}) {
    return _PhoneNumberNotSupported<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _InvalidSubscriptionMode<T> invalidSubscriptionMode<T>(
      {@required T failedValue}) {
    return _InvalidSubscriptionMode<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  ExceedingLength<T> exceedingLength<T>(
      {@required T failedValue, @required int max}) {
    return ExceedingLength<T>(
      failedValue: failedValue,
      max: max,
    );
  }

// ignore: unused_element
  Empty<T> empty<T>({@required T failedValue}) {
    return Empty<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidAccountName<T> invalidAccountName<T>({@required T failedValue}) {
    return InvalidAccountName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidMoneyAmount<T> invalidMoneyAmount<T>({@required T failedValue}) {
    return InvalidMoneyAmount<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidDate<T> invalidDate<T>({@required T failedValue}) {
    return InvalidDate<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidDuration<T> invalidDuration<T>({@required T failedValue}) {
    return InvalidDuration<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  PayoutModeNoteSelected<T> payoutModeNotSelected<T>(
      {@required T failedValue}) {
    return PayoutModeNoteSelected<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  Multiline<T> multiline<T>({@required T failedValue}) {
    return Multiline<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidAddress<T> invalidAddress<T>({@required T failedValue}) {
    return InvalidAddress<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidState<T> invalidState<T>({@required T failedValue}) {
    return InvalidState<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidCity<T> invalidCity<T>({@required T failedValue}) {
    return InvalidCity<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidZipCode<T> invalidZipCode<T>({@required T failedValue}) {
    return InvalidZipCode<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidDefaultLanguage<T> invalidDefaultLanguage<T>(
      {@required T failedValue}) {
    return InvalidDefaultLanguage<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidUserPin<T> invalidUserPin<T>({@required T failedValue}) {
    return InvalidUserPin<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSecurityAnswer<T> invalidSecurityAnswer<T>(
      {@required T failedValue, @required int max}) {
    return InvalidSecurityAnswer<T>(
      failedValue: failedValue,
      max: max,
    );
  }

// ignore: unused_element
  InvalidReputationPoint<T> invalidReputation<T>({@required T failedValue}) {
    return InvalidReputationPoint<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSecurityQuestion<T> invalidSecurityQuestion<T>(
      {@required T failedValue, @required int max}) {
    return InvalidSecurityQuestion<T>(
      failedValue: failedValue,
      max: max,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;
}

/// @nodoc
abstract class $ShortAccountNameCopyWith<T, $Res> {
  factory $ShortAccountNameCopyWith(
          ShortAccountName<T> value, $Res Function(ShortAccountName<T>) then) =
      _$ShortAccountNameCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$ShortAccountNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortAccountNameCopyWith<T, $Res> {
  _$ShortAccountNameCopyWithImpl(
      ShortAccountName<T> _value, $Res Function(ShortAccountName<T>) _then)
      : super(_value, (v) => _then(v as ShortAccountName<T>));

  @override
  ShortAccountName<T> get _value => super._value as ShortAccountName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(ShortAccountName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$ShortAccountName<T> implements ShortAccountName<T> {
  const _$ShortAccountName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortAccountName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ShortAccountName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $ShortAccountNameCopyWith<T, ShortAccountName<T>> get copyWith =>
      _$ShortAccountNameCopyWithImpl<T, ShortAccountName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return shortAccountName(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (shortAccountName != null) {
      return shortAccountName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return shortAccountName(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (shortAccountName != null) {
      return shortAccountName(this);
    }
    return orElse();
  }
}

abstract class ShortAccountName<T> implements ValueFailure<T> {
  const factory ShortAccountName({@required T failedValue}) =
      _$ShortAccountName<T>;

  T get failedValue;
  $ShortAccountNameCopyWith<T, ShortAccountName<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidEmail<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({@required T failedValue}) = _$InvalidEmail<T>;

  T get failedValue;
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidTransactionTypeCopyWith<T, $Res> {
  factory $InvalidTransactionTypeCopyWith(InvalidTransactionType<T> value,
          $Res Function(InvalidTransactionType<T>) then) =
      _$InvalidTransactionTypeCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidTransactionTypeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidTransactionTypeCopyWith<T, $Res> {
  _$InvalidTransactionTypeCopyWithImpl(InvalidTransactionType<T> _value,
      $Res Function(InvalidTransactionType<T>) _then)
      : super(_value, (v) => _then(v as InvalidTransactionType<T>));

  @override
  InvalidTransactionType<T> get _value =>
      super._value as InvalidTransactionType<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidTransactionType<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidTransactionType<T> implements InvalidTransactionType<T> {
  const _$InvalidTransactionType({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidTransactionType(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidTransactionType<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidTransactionTypeCopyWith<T, InvalidTransactionType<T>> get copyWith =>
      _$InvalidTransactionTypeCopyWithImpl<T, InvalidTransactionType<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidTransactionType(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidTransactionType != null) {
      return invalidTransactionType(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidTransactionType(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidTransactionType != null) {
      return invalidTransactionType(this);
    }
    return orElse();
  }
}

abstract class InvalidTransactionType<T> implements ValueFailure<T> {
  const factory InvalidTransactionType({@required T failedValue}) =
      _$InvalidTransactionType<T>;

  T get failedValue;
  $InvalidTransactionTypeCopyWith<T, InvalidTransactionType<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidUserNameCopyWith<T, $Res> {
  factory $InvalidUserNameCopyWith(
          InvalidUserName<T> value, $Res Function(InvalidUserName<T>) then) =
      _$InvalidUserNameCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidUserNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidUserNameCopyWith<T, $Res> {
  _$InvalidUserNameCopyWithImpl(
      InvalidUserName<T> _value, $Res Function(InvalidUserName<T>) _then)
      : super(_value, (v) => _then(v as InvalidUserName<T>));

  @override
  InvalidUserName<T> get _value => super._value as InvalidUserName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidUserName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidUserName<T> implements InvalidUserName<T> {
  const _$InvalidUserName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidUserName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidUserName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidUserNameCopyWith<T, InvalidUserName<T>> get copyWith =>
      _$InvalidUserNameCopyWithImpl<T, InvalidUserName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidUserName(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUserName != null) {
      return invalidUserName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidUserName(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUserName != null) {
      return invalidUserName(this);
    }
    return orElse();
  }
}

abstract class InvalidUserName<T> implements ValueFailure<T> {
  const factory InvalidUserName({@required T failedValue}) =
      _$InvalidUserName<T>;

  T get failedValue;
  $InvalidUserNameCopyWith<T, InvalidUserName<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidStatusCopyWith<T, $Res> {
  factory $InvalidStatusCopyWith(
          InvalidStatus<T> value, $Res Function(InvalidStatus<T>) then) =
      _$InvalidStatusCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidStatusCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidStatusCopyWith<T, $Res> {
  _$InvalidStatusCopyWithImpl(
      InvalidStatus<T> _value, $Res Function(InvalidStatus<T>) _then)
      : super(_value, (v) => _then(v as InvalidStatus<T>));

  @override
  InvalidStatus<T> get _value => super._value as InvalidStatus<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidStatus<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidStatus<T> implements InvalidStatus<T> {
  const _$InvalidStatus({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidStatus(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidStatus<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidStatusCopyWith<T, InvalidStatus<T>> get copyWith =>
      _$InvalidStatusCopyWithImpl<T, InvalidStatus<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidStatus(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidStatus != null) {
      return invalidStatus(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidStatus(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidStatus != null) {
      return invalidStatus(this);
    }
    return orElse();
  }
}

abstract class InvalidStatus<T> implements ValueFailure<T> {
  const factory InvalidStatus({@required T failedValue}) = _$InvalidStatus<T>;

  T get failedValue;
  $InvalidStatusCopyWith<T, InvalidStatus<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidNameCopyWith<T, $Res> {
  factory $InvalidNameCopyWith(
          InvalidName<T> value, $Res Function(InvalidName<T>) then) =
      _$InvalidNameCopyWithImpl<T, $Res>;
  $Res call({T failureValue});
}

/// @nodoc
class _$InvalidNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidNameCopyWith<T, $Res> {
  _$InvalidNameCopyWithImpl(
      InvalidName<T> _value, $Res Function(InvalidName<T>) _then)
      : super(_value, (v) => _then(v as InvalidName<T>));

  @override
  InvalidName<T> get _value => super._value as InvalidName<T>;

  @override
  $Res call({
    Object failureValue = freezed,
  }) {
    return _then(InvalidName<T>(
      failureValue:
          failureValue == freezed ? _value.failureValue : failureValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidName<T> implements InvalidName<T> {
  const _$InvalidName({@required this.failureValue})
      : assert(failureValue != null);

  @override
  final T failureValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidNames(failureValue: $failureValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidName<T> &&
            (identical(other.failureValue, failureValue) ||
                const DeepCollectionEquality()
                    .equals(other.failureValue, failureValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failureValue);

  @override
  $InvalidNameCopyWith<T, InvalidName<T>> get copyWith =>
      _$InvalidNameCopyWithImpl<T, InvalidName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidNames(failureValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidNames != null) {
      return invalidNames(failureValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidNames(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidNames != null) {
      return invalidNames(this);
    }
    return orElse();
  }
}

abstract class InvalidName<T> implements ValueFailure<T> {
  const factory InvalidName({@required T failureValue}) = _$InvalidName<T>;

  T get failureValue;
  $InvalidNameCopyWith<T, InvalidName<T>> get copyWith;
}

/// @nodoc
abstract class _$PhoneNumberNotSupportedCopyWith<T, $Res> {
  factory _$PhoneNumberNotSupportedCopyWith(_PhoneNumberNotSupported<T> value,
          $Res Function(_PhoneNumberNotSupported<T>) then) =
      __$PhoneNumberNotSupportedCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$PhoneNumberNotSupportedCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$PhoneNumberNotSupportedCopyWith<T, $Res> {
  __$PhoneNumberNotSupportedCopyWithImpl(_PhoneNumberNotSupported<T> _value,
      $Res Function(_PhoneNumberNotSupported<T>) _then)
      : super(_value, (v) => _then(v as _PhoneNumberNotSupported<T>));

  @override
  _PhoneNumberNotSupported<T> get _value =>
      super._value as _PhoneNumberNotSupported<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_PhoneNumberNotSupported<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_PhoneNumberNotSupported<T> implements _PhoneNumberNotSupported<T> {
  const _$_PhoneNumberNotSupported({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.phoneNumberNotSupported(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PhoneNumberNotSupported<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$PhoneNumberNotSupportedCopyWith<T, _PhoneNumberNotSupported<T>>
      get copyWith => __$PhoneNumberNotSupportedCopyWithImpl<T,
          _PhoneNumberNotSupported<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return phoneNumberNotSupported(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (phoneNumberNotSupported != null) {
      return phoneNumberNotSupported(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return phoneNumberNotSupported(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (phoneNumberNotSupported != null) {
      return phoneNumberNotSupported(this);
    }
    return orElse();
  }
}

abstract class _PhoneNumberNotSupported<T> implements ValueFailure<T> {
  const factory _PhoneNumberNotSupported({@required T failedValue}) =
      _$_PhoneNumberNotSupported<T>;

  T get failedValue;
  _$PhoneNumberNotSupportedCopyWith<T, _PhoneNumberNotSupported<T>>
      get copyWith;
}

/// @nodoc
abstract class _$InvalidSubscriptionModeCopyWith<T, $Res> {
  factory _$InvalidSubscriptionModeCopyWith(_InvalidSubscriptionMode<T> value,
          $Res Function(_InvalidSubscriptionMode<T>) then) =
      __$InvalidSubscriptionModeCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$InvalidSubscriptionModeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$InvalidSubscriptionModeCopyWith<T, $Res> {
  __$InvalidSubscriptionModeCopyWithImpl(_InvalidSubscriptionMode<T> _value,
      $Res Function(_InvalidSubscriptionMode<T>) _then)
      : super(_value, (v) => _then(v as _InvalidSubscriptionMode<T>));

  @override
  _InvalidSubscriptionMode<T> get _value =>
      super._value as _InvalidSubscriptionMode<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_InvalidSubscriptionMode<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_InvalidSubscriptionMode<T> implements _InvalidSubscriptionMode<T> {
  const _$_InvalidSubscriptionMode({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidSubscriptionMode(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _InvalidSubscriptionMode<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$InvalidSubscriptionModeCopyWith<T, _InvalidSubscriptionMode<T>>
      get copyWith => __$InvalidSubscriptionModeCopyWithImpl<T,
          _InvalidSubscriptionMode<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidSubscriptionMode(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSubscriptionMode != null) {
      return invalidSubscriptionMode(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidSubscriptionMode(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSubscriptionMode != null) {
      return invalidSubscriptionMode(this);
    }
    return orElse();
  }
}

abstract class _InvalidSubscriptionMode<T> implements ValueFailure<T> {
  const factory _InvalidSubscriptionMode({@required T failedValue}) =
      _$_InvalidSubscriptionMode<T>;

  T get failedValue;
  _$InvalidSubscriptionModeCopyWith<T, _InvalidSubscriptionMode<T>>
      get copyWith;
}

/// @nodoc
abstract class $ExceedingLengthCopyWith<T, $Res> {
  factory $ExceedingLengthCopyWith(
          ExceedingLength<T> value, $Res Function(ExceedingLength<T>) then) =
      _$ExceedingLengthCopyWithImpl<T, $Res>;
  $Res call({T failedValue, int max});
}

/// @nodoc
class _$ExceedingLengthCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ExceedingLengthCopyWith<T, $Res> {
  _$ExceedingLengthCopyWithImpl(
      ExceedingLength<T> _value, $Res Function(ExceedingLength<T>) _then)
      : super(_value, (v) => _then(v as ExceedingLength<T>));

  @override
  ExceedingLength<T> get _value => super._value as ExceedingLength<T>;

  @override
  $Res call({
    Object failedValue = freezed,
    Object max = freezed,
  }) {
    return _then(ExceedingLength<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
      max: max == freezed ? _value.max : max as int,
    ));
  }
}

/// @nodoc
class _$ExceedingLength<T> implements ExceedingLength<T> {
  const _$ExceedingLength({@required this.failedValue, @required this.max})
      : assert(failedValue != null),
        assert(max != null);

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'ValueFailure<$T>.exceedingLength(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExceedingLength<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedValue) ^
      const DeepCollectionEquality().hash(max);

  @override
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith =>
      _$ExceedingLengthCopyWithImpl<T, ExceedingLength<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return exceedingLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (exceedingLength != null) {
      return exceedingLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength<T> implements ValueFailure<T> {
  const factory ExceedingLength({@required T failedValue, @required int max}) =
      _$ExceedingLength<T>;

  T get failedValue;
  int get max;
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith;
}

/// @nodoc
abstract class $EmptyCopyWith<T, $Res> {
  factory $EmptyCopyWith(Empty<T> value, $Res Function(Empty<T>) then) =
      _$EmptyCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$EmptyCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $EmptyCopyWith<T, $Res> {
  _$EmptyCopyWithImpl(Empty<T> _value, $Res Function(Empty<T>) _then)
      : super(_value, (v) => _then(v as Empty<T>));

  @override
  Empty<T> get _value => super._value as Empty<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(Empty<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$Empty<T> implements Empty<T> {
  const _$Empty({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.empty(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Empty<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $EmptyCopyWith<T, Empty<T>> get copyWith =>
      _$EmptyCopyWithImpl<T, Empty<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return empty(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty<T> implements ValueFailure<T> {
  const factory Empty({@required T failedValue}) = _$Empty<T>;

  T get failedValue;
  $EmptyCopyWith<T, Empty<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidAccountNameCopyWith<T, $Res> {
  factory $InvalidAccountNameCopyWith(InvalidAccountName<T> value,
          $Res Function(InvalidAccountName<T>) then) =
      _$InvalidAccountNameCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidAccountNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidAccountNameCopyWith<T, $Res> {
  _$InvalidAccountNameCopyWithImpl(
      InvalidAccountName<T> _value, $Res Function(InvalidAccountName<T>) _then)
      : super(_value, (v) => _then(v as InvalidAccountName<T>));

  @override
  InvalidAccountName<T> get _value => super._value as InvalidAccountName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidAccountName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidAccountName<T> implements InvalidAccountName<T> {
  const _$InvalidAccountName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidAccountName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidAccountName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidAccountNameCopyWith<T, InvalidAccountName<T>> get copyWith =>
      _$InvalidAccountNameCopyWithImpl<T, InvalidAccountName<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidAccountName(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidAccountName != null) {
      return invalidAccountName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidAccountName(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidAccountName != null) {
      return invalidAccountName(this);
    }
    return orElse();
  }
}

abstract class InvalidAccountName<T> implements ValueFailure<T> {
  const factory InvalidAccountName({@required T failedValue}) =
      _$InvalidAccountName<T>;

  T get failedValue;
  $InvalidAccountNameCopyWith<T, InvalidAccountName<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidMoneyAmountCopyWith<T, $Res> {
  factory $InvalidMoneyAmountCopyWith(InvalidMoneyAmount<T> value,
          $Res Function(InvalidMoneyAmount<T>) then) =
      _$InvalidMoneyAmountCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidMoneyAmountCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidMoneyAmountCopyWith<T, $Res> {
  _$InvalidMoneyAmountCopyWithImpl(
      InvalidMoneyAmount<T> _value, $Res Function(InvalidMoneyAmount<T>) _then)
      : super(_value, (v) => _then(v as InvalidMoneyAmount<T>));

  @override
  InvalidMoneyAmount<T> get _value => super._value as InvalidMoneyAmount<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidMoneyAmount<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidMoneyAmount<T> implements InvalidMoneyAmount<T> {
  const _$InvalidMoneyAmount({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidMoneyAmount(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidMoneyAmount<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidMoneyAmountCopyWith<T, InvalidMoneyAmount<T>> get copyWith =>
      _$InvalidMoneyAmountCopyWithImpl<T, InvalidMoneyAmount<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidMoneyAmount(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidMoneyAmount != null) {
      return invalidMoneyAmount(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidMoneyAmount(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidMoneyAmount != null) {
      return invalidMoneyAmount(this);
    }
    return orElse();
  }
}

abstract class InvalidMoneyAmount<T> implements ValueFailure<T> {
  const factory InvalidMoneyAmount({@required T failedValue}) =
      _$InvalidMoneyAmount<T>;

  T get failedValue;
  $InvalidMoneyAmountCopyWith<T, InvalidMoneyAmount<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidDateCopyWith<T, $Res> {
  factory $InvalidDateCopyWith(
          InvalidDate<T> value, $Res Function(InvalidDate<T>) then) =
      _$InvalidDateCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidDateCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDateCopyWith<T, $Res> {
  _$InvalidDateCopyWithImpl(
      InvalidDate<T> _value, $Res Function(InvalidDate<T>) _then)
      : super(_value, (v) => _then(v as InvalidDate<T>));

  @override
  InvalidDate<T> get _value => super._value as InvalidDate<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDate<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidDate<T> implements InvalidDate<T> {
  const _$InvalidDate({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDate<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith =>
      _$InvalidDateCopyWithImpl<T, InvalidDate<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidDate(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDate != null) {
      return invalidDate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidDate(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDate != null) {
      return invalidDate(this);
    }
    return orElse();
  }
}

abstract class InvalidDate<T> implements ValueFailure<T> {
  const factory InvalidDate({@required T failedValue}) = _$InvalidDate<T>;

  T get failedValue;
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidDurationCopyWith<T, $Res> {
  factory $InvalidDurationCopyWith(
          InvalidDuration<T> value, $Res Function(InvalidDuration<T>) then) =
      _$InvalidDurationCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidDurationCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDurationCopyWith<T, $Res> {
  _$InvalidDurationCopyWithImpl(
      InvalidDuration<T> _value, $Res Function(InvalidDuration<T>) _then)
      : super(_value, (v) => _then(v as InvalidDuration<T>));

  @override
  InvalidDuration<T> get _value => super._value as InvalidDuration<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDuration<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidDuration<T> implements InvalidDuration<T> {
  const _$InvalidDuration({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDuration(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDuration<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDurationCopyWith<T, InvalidDuration<T>> get copyWith =>
      _$InvalidDurationCopyWithImpl<T, InvalidDuration<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidDuration(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDuration != null) {
      return invalidDuration(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidDuration(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDuration != null) {
      return invalidDuration(this);
    }
    return orElse();
  }
}

abstract class InvalidDuration<T> implements ValueFailure<T> {
  const factory InvalidDuration({@required T failedValue}) =
      _$InvalidDuration<T>;

  T get failedValue;
  $InvalidDurationCopyWith<T, InvalidDuration<T>> get copyWith;
}

/// @nodoc
abstract class $PayoutModeNoteSelectedCopyWith<T, $Res> {
  factory $PayoutModeNoteSelectedCopyWith(PayoutModeNoteSelected<T> value,
          $Res Function(PayoutModeNoteSelected<T>) then) =
      _$PayoutModeNoteSelectedCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$PayoutModeNoteSelectedCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $PayoutModeNoteSelectedCopyWith<T, $Res> {
  _$PayoutModeNoteSelectedCopyWithImpl(PayoutModeNoteSelected<T> _value,
      $Res Function(PayoutModeNoteSelected<T>) _then)
      : super(_value, (v) => _then(v as PayoutModeNoteSelected<T>));

  @override
  PayoutModeNoteSelected<T> get _value =>
      super._value as PayoutModeNoteSelected<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(PayoutModeNoteSelected<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$PayoutModeNoteSelected<T> implements PayoutModeNoteSelected<T> {
  const _$PayoutModeNoteSelected({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.payoutModeNotSelected(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayoutModeNoteSelected<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $PayoutModeNoteSelectedCopyWith<T, PayoutModeNoteSelected<T>> get copyWith =>
      _$PayoutModeNoteSelectedCopyWithImpl<T, PayoutModeNoteSelected<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return payoutModeNotSelected(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (payoutModeNotSelected != null) {
      return payoutModeNotSelected(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return payoutModeNotSelected(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (payoutModeNotSelected != null) {
      return payoutModeNotSelected(this);
    }
    return orElse();
  }
}

abstract class PayoutModeNoteSelected<T> implements ValueFailure<T> {
  const factory PayoutModeNoteSelected({@required T failedValue}) =
      _$PayoutModeNoteSelected<T>;

  T get failedValue;
  $PayoutModeNoteSelectedCopyWith<T, PayoutModeNoteSelected<T>> get copyWith;
}

/// @nodoc
abstract class $MultilineCopyWith<T, $Res> {
  factory $MultilineCopyWith(
          Multiline<T> value, $Res Function(Multiline<T>) then) =
      _$MultilineCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$MultilineCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $MultilineCopyWith<T, $Res> {
  _$MultilineCopyWithImpl(
      Multiline<T> _value, $Res Function(Multiline<T>) _then)
      : super(_value, (v) => _then(v as Multiline<T>));

  @override
  Multiline<T> get _value => super._value as Multiline<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(Multiline<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$Multiline<T> implements Multiline<T> {
  const _$Multiline({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.multiline(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Multiline<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $MultilineCopyWith<T, Multiline<T>> get copyWith =>
      _$MultilineCopyWithImpl<T, Multiline<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return multiline(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (multiline != null) {
      return multiline(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return multiline(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (multiline != null) {
      return multiline(this);
    }
    return orElse();
  }
}

abstract class Multiline<T> implements ValueFailure<T> {
  const factory Multiline({@required T failedValue}) = _$Multiline<T>;

  T get failedValue;
  $MultilineCopyWith<T, Multiline<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidAddressCopyWith<T, $Res> {
  factory $InvalidAddressCopyWith(
          InvalidAddress<T> value, $Res Function(InvalidAddress<T>) then) =
      _$InvalidAddressCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidAddressCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidAddressCopyWith<T, $Res> {
  _$InvalidAddressCopyWithImpl(
      InvalidAddress<T> _value, $Res Function(InvalidAddress<T>) _then)
      : super(_value, (v) => _then(v as InvalidAddress<T>));

  @override
  InvalidAddress<T> get _value => super._value as InvalidAddress<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidAddress<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidAddress<T> implements InvalidAddress<T> {
  const _$InvalidAddress({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidAddress(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidAddress<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidAddressCopyWith<T, InvalidAddress<T>> get copyWith =>
      _$InvalidAddressCopyWithImpl<T, InvalidAddress<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidAddress(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidAddress != null) {
      return invalidAddress(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidAddress(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidAddress != null) {
      return invalidAddress(this);
    }
    return orElse();
  }
}

abstract class InvalidAddress<T> implements ValueFailure<T> {
  const factory InvalidAddress({@required T failedValue}) = _$InvalidAddress<T>;

  T get failedValue;
  $InvalidAddressCopyWith<T, InvalidAddress<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidStateCopyWith<T, $Res> {
  factory $InvalidStateCopyWith(
          InvalidState<T> value, $Res Function(InvalidState<T>) then) =
      _$InvalidStateCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidStateCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidStateCopyWith<T, $Res> {
  _$InvalidStateCopyWithImpl(
      InvalidState<T> _value, $Res Function(InvalidState<T>) _then)
      : super(_value, (v) => _then(v as InvalidState<T>));

  @override
  InvalidState<T> get _value => super._value as InvalidState<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidState<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidState<T> implements InvalidState<T> {
  const _$InvalidState({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidState(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidState<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidStateCopyWith<T, InvalidState<T>> get copyWith =>
      _$InvalidStateCopyWithImpl<T, InvalidState<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidState(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidState != null) {
      return invalidState(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidState(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidState != null) {
      return invalidState(this);
    }
    return orElse();
  }
}

abstract class InvalidState<T> implements ValueFailure<T> {
  const factory InvalidState({@required T failedValue}) = _$InvalidState<T>;

  T get failedValue;
  $InvalidStateCopyWith<T, InvalidState<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidCityCopyWith<T, $Res> {
  factory $InvalidCityCopyWith(
          InvalidCity<T> value, $Res Function(InvalidCity<T>) then) =
      _$InvalidCityCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidCityCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidCityCopyWith<T, $Res> {
  _$InvalidCityCopyWithImpl(
      InvalidCity<T> _value, $Res Function(InvalidCity<T>) _then)
      : super(_value, (v) => _then(v as InvalidCity<T>));

  @override
  InvalidCity<T> get _value => super._value as InvalidCity<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidCity<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidCity<T> implements InvalidCity<T> {
  const _$InvalidCity({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidCity(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCity<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidCityCopyWith<T, InvalidCity<T>> get copyWith =>
      _$InvalidCityCopyWithImpl<T, InvalidCity<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidCity(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidCity != null) {
      return invalidCity(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidCity(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidCity != null) {
      return invalidCity(this);
    }
    return orElse();
  }
}

abstract class InvalidCity<T> implements ValueFailure<T> {
  const factory InvalidCity({@required T failedValue}) = _$InvalidCity<T>;

  T get failedValue;
  $InvalidCityCopyWith<T, InvalidCity<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidZipCodeCopyWith<T, $Res> {
  factory $InvalidZipCodeCopyWith(
          InvalidZipCode<T> value, $Res Function(InvalidZipCode<T>) then) =
      _$InvalidZipCodeCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidZipCodeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidZipCodeCopyWith<T, $Res> {
  _$InvalidZipCodeCopyWithImpl(
      InvalidZipCode<T> _value, $Res Function(InvalidZipCode<T>) _then)
      : super(_value, (v) => _then(v as InvalidZipCode<T>));

  @override
  InvalidZipCode<T> get _value => super._value as InvalidZipCode<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidZipCode<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidZipCode<T> implements InvalidZipCode<T> {
  const _$InvalidZipCode({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidZipCode(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidZipCode<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidZipCodeCopyWith<T, InvalidZipCode<T>> get copyWith =>
      _$InvalidZipCodeCopyWithImpl<T, InvalidZipCode<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidZipCode(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidZipCode != null) {
      return invalidZipCode(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidZipCode(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidZipCode != null) {
      return invalidZipCode(this);
    }
    return orElse();
  }
}

abstract class InvalidZipCode<T> implements ValueFailure<T> {
  const factory InvalidZipCode({@required T failedValue}) = _$InvalidZipCode<T>;

  T get failedValue;
  $InvalidZipCodeCopyWith<T, InvalidZipCode<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidDefaultLanguageCopyWith<T, $Res> {
  factory $InvalidDefaultLanguageCopyWith(InvalidDefaultLanguage<T> value,
          $Res Function(InvalidDefaultLanguage<T>) then) =
      _$InvalidDefaultLanguageCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidDefaultLanguageCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDefaultLanguageCopyWith<T, $Res> {
  _$InvalidDefaultLanguageCopyWithImpl(InvalidDefaultLanguage<T> _value,
      $Res Function(InvalidDefaultLanguage<T>) _then)
      : super(_value, (v) => _then(v as InvalidDefaultLanguage<T>));

  @override
  InvalidDefaultLanguage<T> get _value =>
      super._value as InvalidDefaultLanguage<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDefaultLanguage<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidDefaultLanguage<T> implements InvalidDefaultLanguage<T> {
  const _$InvalidDefaultLanguage({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDefaultLanguage(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDefaultLanguage<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDefaultLanguageCopyWith<T, InvalidDefaultLanguage<T>> get copyWith =>
      _$InvalidDefaultLanguageCopyWithImpl<T, InvalidDefaultLanguage<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidDefaultLanguage(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDefaultLanguage != null) {
      return invalidDefaultLanguage(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidDefaultLanguage(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDefaultLanguage != null) {
      return invalidDefaultLanguage(this);
    }
    return orElse();
  }
}

abstract class InvalidDefaultLanguage<T> implements ValueFailure<T> {
  const factory InvalidDefaultLanguage({@required T failedValue}) =
      _$InvalidDefaultLanguage<T>;

  T get failedValue;
  $InvalidDefaultLanguageCopyWith<T, InvalidDefaultLanguage<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidUserPinCopyWith<T, $Res> {
  factory $InvalidUserPinCopyWith(
          InvalidUserPin<T> value, $Res Function(InvalidUserPin<T>) then) =
      _$InvalidUserPinCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidUserPinCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidUserPinCopyWith<T, $Res> {
  _$InvalidUserPinCopyWithImpl(
      InvalidUserPin<T> _value, $Res Function(InvalidUserPin<T>) _then)
      : super(_value, (v) => _then(v as InvalidUserPin<T>));

  @override
  InvalidUserPin<T> get _value => super._value as InvalidUserPin<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidUserPin<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidUserPin<T> implements InvalidUserPin<T> {
  const _$InvalidUserPin({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidUserPin(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidUserPin<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidUserPinCopyWith<T, InvalidUserPin<T>> get copyWith =>
      _$InvalidUserPinCopyWithImpl<T, InvalidUserPin<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidUserPin(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUserPin != null) {
      return invalidUserPin(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidUserPin(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUserPin != null) {
      return invalidUserPin(this);
    }
    return orElse();
  }
}

abstract class InvalidUserPin<T> implements ValueFailure<T> {
  const factory InvalidUserPin({@required T failedValue}) = _$InvalidUserPin<T>;

  T get failedValue;
  $InvalidUserPinCopyWith<T, InvalidUserPin<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSecurityAnswerCopyWith<T, $Res> {
  factory $InvalidSecurityAnswerCopyWith(InvalidSecurityAnswer<T> value,
          $Res Function(InvalidSecurityAnswer<T>) then) =
      _$InvalidSecurityAnswerCopyWithImpl<T, $Res>;
  $Res call({T failedValue, int max});
}

/// @nodoc
class _$InvalidSecurityAnswerCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidSecurityAnswerCopyWith<T, $Res> {
  _$InvalidSecurityAnswerCopyWithImpl(InvalidSecurityAnswer<T> _value,
      $Res Function(InvalidSecurityAnswer<T>) _then)
      : super(_value, (v) => _then(v as InvalidSecurityAnswer<T>));

  @override
  InvalidSecurityAnswer<T> get _value =>
      super._value as InvalidSecurityAnswer<T>;

  @override
  $Res call({
    Object failedValue = freezed,
    Object max = freezed,
  }) {
    return _then(InvalidSecurityAnswer<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
      max: max == freezed ? _value.max : max as int,
    ));
  }
}

/// @nodoc
class _$InvalidSecurityAnswer<T> implements InvalidSecurityAnswer<T> {
  const _$InvalidSecurityAnswer(
      {@required this.failedValue, @required this.max})
      : assert(failedValue != null),
        assert(max != null);

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidSecurityAnswer(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSecurityAnswer<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedValue) ^
      const DeepCollectionEquality().hash(max);

  @override
  $InvalidSecurityAnswerCopyWith<T, InvalidSecurityAnswer<T>> get copyWith =>
      _$InvalidSecurityAnswerCopyWithImpl<T, InvalidSecurityAnswer<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidSecurityAnswer(failedValue, max);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSecurityAnswer != null) {
      return invalidSecurityAnswer(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidSecurityAnswer(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSecurityAnswer != null) {
      return invalidSecurityAnswer(this);
    }
    return orElse();
  }
}

abstract class InvalidSecurityAnswer<T> implements ValueFailure<T> {
  const factory InvalidSecurityAnswer(
      {@required T failedValue,
      @required int max}) = _$InvalidSecurityAnswer<T>;

  T get failedValue;
  int get max;
  $InvalidSecurityAnswerCopyWith<T, InvalidSecurityAnswer<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidReputationPointCopyWith<T, $Res> {
  factory $InvalidReputationPointCopyWith(InvalidReputationPoint<T> value,
          $Res Function(InvalidReputationPoint<T>) then) =
      _$InvalidReputationPointCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidReputationPointCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidReputationPointCopyWith<T, $Res> {
  _$InvalidReputationPointCopyWithImpl(InvalidReputationPoint<T> _value,
      $Res Function(InvalidReputationPoint<T>) _then)
      : super(_value, (v) => _then(v as InvalidReputationPoint<T>));

  @override
  InvalidReputationPoint<T> get _value =>
      super._value as InvalidReputationPoint<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidReputationPoint<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidReputationPoint<T> implements InvalidReputationPoint<T> {
  const _$InvalidReputationPoint({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidReputation(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidReputationPoint<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidReputationPointCopyWith<T, InvalidReputationPoint<T>> get copyWith =>
      _$InvalidReputationPointCopyWithImpl<T, InvalidReputationPoint<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidReputation(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidReputation != null) {
      return invalidReputation(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidReputation(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidReputation != null) {
      return invalidReputation(this);
    }
    return orElse();
  }
}

abstract class InvalidReputationPoint<T> implements ValueFailure<T> {
  const factory InvalidReputationPoint({@required T failedValue}) =
      _$InvalidReputationPoint<T>;

  T get failedValue;
  $InvalidReputationPointCopyWith<T, InvalidReputationPoint<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSecurityQuestionCopyWith<T, $Res> {
  factory $InvalidSecurityQuestionCopyWith(InvalidSecurityQuestion<T> value,
          $Res Function(InvalidSecurityQuestion<T>) then) =
      _$InvalidSecurityQuestionCopyWithImpl<T, $Res>;
  $Res call({T failedValue, int max});
}

/// @nodoc
class _$InvalidSecurityQuestionCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidSecurityQuestionCopyWith<T, $Res> {
  _$InvalidSecurityQuestionCopyWithImpl(InvalidSecurityQuestion<T> _value,
      $Res Function(InvalidSecurityQuestion<T>) _then)
      : super(_value, (v) => _then(v as InvalidSecurityQuestion<T>));

  @override
  InvalidSecurityQuestion<T> get _value =>
      super._value as InvalidSecurityQuestion<T>;

  @override
  $Res call({
    Object failedValue = freezed,
    Object max = freezed,
  }) {
    return _then(InvalidSecurityQuestion<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
      max: max == freezed ? _value.max : max as int,
    ));
  }
}

/// @nodoc
class _$InvalidSecurityQuestion<T> implements InvalidSecurityQuestion<T> {
  const _$InvalidSecurityQuestion(
      {@required this.failedValue, @required this.max})
      : assert(failedValue != null),
        assert(max != null);

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidSecurityQuestion(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSecurityQuestion<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedValue) ^
      const DeepCollectionEquality().hash(max);

  @override
  $InvalidSecurityQuestionCopyWith<T, InvalidSecurityQuestion<T>>
      get copyWith =>
          _$InvalidSecurityQuestionCopyWithImpl<T, InvalidSecurityQuestion<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result shortAccountName(T failedValue),
    @required Result invalidEmail(T failedValue),
    @required Result invalidTransactionType(T failedValue),
    @required Result invalidUserName(T failedValue),
    @required Result invalidStatus(T failedValue),
    @required Result invalidNames(T failureValue),
    @required Result phoneNumberNotSupported(T failedValue),
    @required Result invalidSubscriptionMode(T failedValue),
    @required Result exceedingLength(T failedValue, int max),
    @required Result empty(T failedValue),
    @required Result invalidAccountName(T failedValue),
    @required Result invalidMoneyAmount(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidDuration(T failedValue),
    @required Result payoutModeNotSelected(T failedValue),
    @required Result multiline(T failedValue),
    @required Result invalidAddress(T failedValue),
    @required Result invalidState(T failedValue),
    @required Result invalidCity(T failedValue),
    @required Result invalidZipCode(T failedValue),
    @required Result invalidDefaultLanguage(T failedValue),
    @required Result invalidUserPin(T failedValue),
    @required Result invalidSecurityAnswer(T failedValue, int max),
    @required Result invalidReputation(T failedValue),
    @required Result invalidSecurityQuestion(T failedValue, int max),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidSecurityQuestion(failedValue, max);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result shortAccountName(T failedValue),
    Result invalidEmail(T failedValue),
    Result invalidTransactionType(T failedValue),
    Result invalidUserName(T failedValue),
    Result invalidStatus(T failedValue),
    Result invalidNames(T failureValue),
    Result phoneNumberNotSupported(T failedValue),
    Result invalidSubscriptionMode(T failedValue),
    Result exceedingLength(T failedValue, int max),
    Result empty(T failedValue),
    Result invalidAccountName(T failedValue),
    Result invalidMoneyAmount(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidDuration(T failedValue),
    Result payoutModeNotSelected(T failedValue),
    Result multiline(T failedValue),
    Result invalidAddress(T failedValue),
    Result invalidState(T failedValue),
    Result invalidCity(T failedValue),
    Result invalidZipCode(T failedValue),
    Result invalidDefaultLanguage(T failedValue),
    Result invalidUserPin(T failedValue),
    Result invalidSecurityAnswer(T failedValue, int max),
    Result invalidReputation(T failedValue),
    Result invalidSecurityQuestion(T failedValue, int max),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSecurityQuestion != null) {
      return invalidSecurityQuestion(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result shortAccountName(ShortAccountName<T> value),
    @required Result invalidEmail(InvalidEmail<T> value),
    @required Result invalidTransactionType(InvalidTransactionType<T> value),
    @required Result invalidUserName(InvalidUserName<T> value),
    @required Result invalidStatus(InvalidStatus<T> value),
    @required Result invalidNames(InvalidName<T> value),
    @required Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    @required Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    @required Result exceedingLength(ExceedingLength<T> value),
    @required Result empty(Empty<T> value),
    @required Result invalidAccountName(InvalidAccountName<T> value),
    @required Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidDuration(InvalidDuration<T> value),
    @required Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    @required Result multiline(Multiline<T> value),
    @required Result invalidAddress(InvalidAddress<T> value),
    @required Result invalidState(InvalidState<T> value),
    @required Result invalidCity(InvalidCity<T> value),
    @required Result invalidZipCode(InvalidZipCode<T> value),
    @required Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    @required Result invalidUserPin(InvalidUserPin<T> value),
    @required Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    @required Result invalidReputation(InvalidReputationPoint<T> value),
    @required Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
  }) {
    assert(shortAccountName != null);
    assert(invalidEmail != null);
    assert(invalidTransactionType != null);
    assert(invalidUserName != null);
    assert(invalidStatus != null);
    assert(invalidNames != null);
    assert(phoneNumberNotSupported != null);
    assert(invalidSubscriptionMode != null);
    assert(exceedingLength != null);
    assert(empty != null);
    assert(invalidAccountName != null);
    assert(invalidMoneyAmount != null);
    assert(invalidDate != null);
    assert(invalidDuration != null);
    assert(payoutModeNotSelected != null);
    assert(multiline != null);
    assert(invalidAddress != null);
    assert(invalidState != null);
    assert(invalidCity != null);
    assert(invalidZipCode != null);
    assert(invalidDefaultLanguage != null);
    assert(invalidUserPin != null);
    assert(invalidSecurityAnswer != null);
    assert(invalidReputation != null);
    assert(invalidSecurityQuestion != null);
    return invalidSecurityQuestion(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result shortAccountName(ShortAccountName<T> value),
    Result invalidEmail(InvalidEmail<T> value),
    Result invalidTransactionType(InvalidTransactionType<T> value),
    Result invalidUserName(InvalidUserName<T> value),
    Result invalidStatus(InvalidStatus<T> value),
    Result invalidNames(InvalidName<T> value),
    Result phoneNumberNotSupported(_PhoneNumberNotSupported<T> value),
    Result invalidSubscriptionMode(_InvalidSubscriptionMode<T> value),
    Result exceedingLength(ExceedingLength<T> value),
    Result empty(Empty<T> value),
    Result invalidAccountName(InvalidAccountName<T> value),
    Result invalidMoneyAmount(InvalidMoneyAmount<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidDuration(InvalidDuration<T> value),
    Result payoutModeNotSelected(PayoutModeNoteSelected<T> value),
    Result multiline(Multiline<T> value),
    Result invalidAddress(InvalidAddress<T> value),
    Result invalidState(InvalidState<T> value),
    Result invalidCity(InvalidCity<T> value),
    Result invalidZipCode(InvalidZipCode<T> value),
    Result invalidDefaultLanguage(InvalidDefaultLanguage<T> value),
    Result invalidUserPin(InvalidUserPin<T> value),
    Result invalidSecurityAnswer(InvalidSecurityAnswer<T> value),
    Result invalidReputation(InvalidReputationPoint<T> value),
    Result invalidSecurityQuestion(InvalidSecurityQuestion<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSecurityQuestion != null) {
      return invalidSecurityQuestion(this);
    }
    return orElse();
  }
}

abstract class InvalidSecurityQuestion<T> implements ValueFailure<T> {
  const factory InvalidSecurityQuestion(
      {@required T failedValue,
      @required int max}) = _$InvalidSecurityQuestion<T>;

  T get failedValue;
  int get max;
  $InvalidSecurityQuestionCopyWith<T, InvalidSecurityQuestion<T>> get copyWith;
}
